<input type="checkbox" id="isClose"></input><div class="left-menu"><div class="control-panel"><label for="isClose"><div class="isClose"></div></label></div><div class="left-side-menu"><ul><a href="#блочная-модель"><li>Блочная модель</li></a><ul><a href="#устройство-блока"><li>Устройство блока</li></a></ul><a href="#внешний-тип"><li>Внешний тип</li></a><a href="#внутренний-тип"><li>Внутренний тип</li></a><a href="#layout-расположение-элементов"><li>Layout. Расположение элементов</li></a><ul><a href="#normal-flow"><li>Normal Flow</li></a><a href="#display"><li>Display</li></a><a href="#position"><li>Position</li></a><a href="#flex"><li>Flex</li></a><a href="#grid"><li>Grid</li></a><a href="#table"><li>Table</li></a><a href="#floats"><li>Floats</li></a><a href="#multi-column-layout"><li>Multi-column layout</li></a></ul></ul></div></div><div class="main"><link rel="stylesheet" href="..\..\static\style.css "><h1 id="блочная-модель">Блочная модель</h1>
<p>Основное понятие в CSS. То как элементы типа block и inline располагаются</p>
<h2 id="устройство-блока">Устройство блока</h2>
<ul>
<li>margin - внешний отступ</li>
<li>border - граница. Точнее рамка вокруг</li>
<li>padding - внутренний отступ</li>
<li>content - содержание</li>
</ul>
<p>![Устройство блока](./source/block-strucure.svg =300x250)</p>
<h1 id="внешний-тип">Внешний тип</h1>
<p>Задает внешнее поведение</p>
<table>
<thead>
<tr>
<th style="text-align:left">display: inline</th>
<th style="text-align:left">display: block</th>
<th style="text-align:left">display: inline-block</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Останется в <strong>той же</strong> строке</td>
<td style="text-align:left">Начнется с <strong>новой</strong> строки</td>
<td style="text-align:left">Останется в <strong>той же</strong> строке</td>
</tr>
<tr>
<td style="text-align:left">width и height <strong>не</strong> применяются</td>
<td style="text-align:left">width и height применяются</td>
<td style="text-align:left">width и height применяются</td>
</tr>
<tr>
<td style="text-align:left"><strong>Горизонтальные</strong> отступы будут отодвигать другие <strong>inline</strong> элементы</td>
<td style="text-align:left">Отступы будут отодвигать от него элементы</td>
<td style="text-align:left">Отступы будут отодвигать от него элементы</td>
</tr>
<tr>
<td style="text-align:left"><strong>Вертикальные</strong> отступы будут применяться но <strong>НЕ БУДУТ</strong> отодвигать <strong>inline</strong> элементы</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">Будет заполнять всю ширину родителя</td>
<td style="text-align:left">Размеры будут больше содержимого только если явно задать</td>
</tr>
<tr>
<td style="text-align:left"><img src="./source/display-inline.svg" alt="Устройство блока"></td>
<td style="text-align:left">![Устройство блока](./source/display-block.svg =100x100)</td>
<td style="text-align:left"><img src="./source/display-inline-block.svg" alt="Устройство блока"></td>
</tr>
</tbody>
</table>
<h1 id="внутренний-тип">Внутренний тип</h1>
<p>Задает внутреннее поведение блока</p>
<p>К нему относят только flex, grid. Но лучше чекни <a href="#layout-%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2">Layout CSS</a></p>
<h1 id="layout-расположение-элементов">Layout. Расположение элементов</h1>
<h2 id="normal-flow">Normal Flow</h2>
<p>Normal flow. Использует стандартные свойства у tag'ов для отоброжения. Поведение по умолчанию.</p>
<p>Такое поведение описано <a href="#%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B8%D0%B9-%D1%82%D0%B8%D0%BF">здесь</a></p>
<h2 id="display">Display</h2>
<p>Display. Можно поменять у tag'ов свойство, чтобы они стали inline/block/block-inline</p>
<pre><code class="hljs language-css"><span class="hljs-attribute">display</span>: inline;
<span class="hljs-attribute">display</span>: block;
<span class="hljs-attribute">display</span>: block-inline;
</code></pre>
<h2 id="position">Position</h2>
<p>Переместить из нормального потока в другое место.</p>
<p>Все значения аттрибута position, кроме static, делают элемент позиционированным. То бишь, потомки располагаются относительно его нового положения</p>
<p>Достаточно просто указать свойство position и работать с ним:
position: static; - по умолчанию (просто Normal Flow)
position: relative; - меняет положение относительно положения по умолчанию или относительно ближащго позиционированного предка
position: absolute; - удаляет элемент из нормального потока так, будто бы на своем отдельном слое. Положение можно менять относительно html или относительно ближащго позиционированного предка
position: fixed; - фиксирует элемент относительно viewport'а. Короче при прокрутке страницы элемент остается на месте
position: sticky; - элемент ведет себя как static. После достижения определенной линии viewport прикрепляется к ней</p>
<p>Располагаются элементы с помощью свойств: top / left / right / bottom</p>
<p>z-index: ; - управляет &quot;высотой&quot; элементов. Высокие значения - сверху. Работает только:</p>
<ul>
<li>элементы должны находитсься на одном иерархическом уровне</li>
<li>для позиционированных элементов(position которых НЕ static)</li>
<li>для flex и grid элементов</li>
<li>для элементо чей opacity &lt; 1, например 0.999</li>
</ul>
<h2 id="flex">Flex</h2>
<p>Выставляет элементы либо в ряд либо в колонку</p>
<p>Свойства flex-wrapper:
display: flex; - указываем что это элемент-обертка типа flex. Расставляет block'и как flex-block
display: inline-flex; - указываем что это элемент-обертка типа flex. Расставляет inline как flex-block</p>
<p>flex-direction: row | column | row-reverse | column-reverse; - распологать flex-block в строку/ряд/строку-задом-наперед/столбец-задом-наперед
flex-wrap: wrap | no-wrap; - если flex-blok не помещается, то переносит/не-переносит на следующую строку</p>
<p>align-items: stretch | center | flex-start | flex-end; - указывае где элемент находится на поперечной(перпендекулярна оси направления) оси. Значение stretch - растягивает элементы, все остальные выравнивают
justify-content: flex-start | center | flex-end | space-around |
align-content: flex-start | center | flex-end | stretch | space-between | space-around; - если строк поперечной(перпендекулярна оси направления) оси в контейнере больше двух, а в контейнере еще есть место, то это позволяет управлять расположением этих строк</p>
<p>space-between; - располагает элементы вдоль главной(ось направления) оси. Свойство space-around - распределяет все элементы равномерно с небольшим количеством свободного места на концах. Свойство space-between - как space-around, но не остваляет место на концах
row-gap: ; - отступы между строками
column-gap: ; - оступы между столбцами</p>
<p>Свойства flex-block:
flex-grow: ; - распределит flex-block согласно указанным весам
flex-shrink: ; - если во flex-wrapper не хватает места, то flex-block будут уменьшаться согласно указанным весам
flex-basis: ; - сначало элемент примет значение , а потом оставшееся место будет разделено
flex: ; - сокращенный вариант для свойств выше. Значения обозначают flex-grow, flex-shrink и flex-basis. Так же можно не указывать второе свойство</p>
<p>align-self: ...; - работает точно так же как align-items, но только один flex-block
order: ; - элемент снаибольшим значением идет в конец главной(ось направления) оси. Значение может быть отрицательным</p>
<h2 id="grid">Grid</h2>
<p>Выстраивает элементы в двумерную сетку</p>
<p>По рядам и столбцам.</p>
<p>Свойства grid-wraper:
display: grid; - указываем что это элемент-обертка. И он является grid. Элемент-обертка ведет себя как block
display: inline-grid; - указываем что это элемент-обертка. И он является grid. Элемент-обертка ведет себя как inline</p>
<p>grid-template-columns: 40px auto 40%; - создаст три колонки
grid-template-columns: [start line1] 150px [line2] 40%; - создает две колонки. Дальше в CSS к ним можно будет обращаться по именам заданным в [...]. У первой колонки двойное имя
grid-template-columns: repeat(3, 250px); - три одинаковых колонки
grid-template-columns: 1fr 2fr 1fr 200px; - колонки с весами(fr). Специального для grid введенное размерность. Веса расщитываютс после фиксированных размеров
grid-template- rows: ...; - все что выше написано о gr...-columns относится к текущему свойству. Но текущее свойство создает строки</p>
<p>gap: 10px; - делает отступ в 10px между строками и между столбцами
gap: 10px 20px; - делает отступ в 10px между строками и 20px между столбцами
column-gap: 10px; - делает отступ в 10px между столбцами
row-gap: 50px; - делает отступ в 50px между строками</p>
<p>grid-auto-columns: 50px 150px; - для невлезжих в сетку элементов, будут создаваться колонки с указанными ширинами с повтором значений ширины
grid-auto-rows: ...; - тоже что grid-auto-columns, но для строк
grid-auto-flow: row | column; - для невлезжих элементов будет создавать строки/колонки
grid-auto-flow: dense row | column; - невлезшими элементами будет сначало заполнять пустые ячейки, а потом создавать строки/колонки</p>
<p>justify-items: start | center | end | stretch; - выравние элементов по горизонтальной оси
align-items: start | center | end | stretch; - выравние элементов по вертикальной оси</p>
<p>grid-template-areas:
&quot;header header header&quot;
&quot;content content 👾&quot;
&quot;content content .&quot;
&quot;footer footer footer&quot;; - после задания числа и размеров строк и столбцов, можно разбить сетку на области. Значение этого свойтва - это имена областей. Необходимо указать область для каждой ячейки. Точка обозначает пустую область в которой ничего нет
grid-area: areaName; - укзав это совйоство в grid-block, элемент займет всю область проименованную в grid-template-areas</p>
<p>Свойства grid-block:
justify-self: start | center | end | stretch; - выравние этого элемента по горизонтальной оси
align-self: start | center | end | stretch; - выравние этого элемента по вертикальной оси</p>
<p>grid-column-start / grid-column-end / grid-row-start / grid-row-end - эти свойства определяют положение grid-block. То как их указывать описано ниже:
grid-...-...: line1; - определяет положение по имени строки/столбца
grid-...-...: 2; - определяет положение по порядковому строки/столбца
grid-...-end: line1; - растягивает до имени строки/столбца
grid-...-end: span 2; - растягивает на две ячейки</p>
<p>grid-area: 1 / col4-start / last-line / 6; - шорткат для 4 свойств выше. Работает в следующем порядке: grid-row-start / grid-column-start / grid-row-end / grid-column-end</p>
<h2 id="table">Table</h2>
<p>Свойство рзметки для нетабличных элементов
Очевидно создаем таблицу и в ней располагаем контент ао строкам и столбцам. УСТАРЕЛО, не использовать</p>
<h2 id="floats">Floats</h2>
<p>Может заставить &quot;прилепить&quot; содержимое блочного элемента к одной стороне другого элемента
float: left | right | none | inherit; - элемент выравнивается по указанной стороне. Остальные последующие элементы, пытаются занять местот так, будто нашего float элемента нет, но видят что он есть и начинают его &quot;обтекать&quot;
clear: left | right | both; - элемент на котором это свойсвто, перестанет пытаться обтекать и просто будет в конце</p>
<p>clearfix hack - если float работает не так как ты думал, чекни</p>
<h2 id="multi-column-layout">Multi-column layout</h2>
<p>Расположить содержимое столбцами как в газетах. Так же с ним работают свойства фрагментации
Для этого надо просто указать блоку 1-о из свойств:
column-count: ; - разделит блок на равные колонки и будет пихать контент в них
column-width: ; - разделит на как можно большее число столбцов как минимум указанной ширины
column-gap: ; - растояние между столбцами
column-rule: 4px dotted rgb(79, 185, 227); - создает линию, типа border, между столбцами
column-span: none | all; - элемент прерывает делениие на столбцы, занимая все стобцы. После текст снова распределяется по столбцам</p>
</div>