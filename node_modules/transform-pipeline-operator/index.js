acorn = require('acorn');

tokTypes = acorn.tokTypes;
TokenType = acorn.TokenType;

tokTypes.pipe = new TokenType("|>", { beforeExpr: true, binop: 10 });
tokTypes.pipeResult = new TokenType("%%");

getTokenFromCode = acorn.Parser.prototype.getTokenFromCode; 
acorn.Parser.prototype.getTokenFromCode = function( code ) {
    switch (code) {
            // editable
        case 124: // '|'
            if( this.input.charCodeAt(this.pos + 1) === 62 ) {
                return this.readToken_pipe( );
            }
            // editable
        case 37: // '%%'
    console.log('here');
    console.log(this.pos);
            if( this.input.charCodeAt(this.pos + 1) === 37 ) {
                return this.readToken_pipe_result( );
            }
    }
    return getTokenFromCode.call( this, code );
};

acorn.Parser.prototype.readToken_pipe = function( ) {
    return this.finishOp(tokTypes.pipe, 2)
};

acorn.Parser.prototype.readToken_pipe_result = function( ) {
    return this.finishOp(tokTypes.pipeResult, 2)
};


parseExprAtom = acorn.Parser.prototype.parseExprAtom; 
acorn.Parser.prototype.parseExprAtom = function (refDestructuringErrors, forInit) {
    var node, canBeArrow = this.potentialArrowAt === this.start;
    if( this.type === tokTypes.pipeResult ) {
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var node = this.startNode();
        node.name = '%%';
        this.next(false);
        this.finishNode(node, "Identifier");

        var id = node;
        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(tokTypes._function)) {
            this.overrideContext(types.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
        }
        if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(tokTypes.arrow))
            { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === tokTypes.name && !containsEsc &&
                (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(tokTypes.arrow))
                { this.unexpected(); }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
            }
        }
        return id
    }

    return parseExprAtom.call(this, refDestructuringErrors, forInit);
}




acornWalkAST = require('acorn-walkAST');

let UpdatePipeExpression = {
    __proto__: acornWalkAST.UpdateNodes,
    pipeVariableName: 'arguments[0]',

    BinaryExpression: function (node) {
        let length = this.__proto__.BinaryExpression.call(this, node);
        if( node.operator === '|>' ) {
            let newCode, offset;
            newCode = '(function() { return ' + this.code.slice( node.right.start, node.right.end ) + '})(' + this.code.slice( node.left.start, node.left.end ) + ')';
            console.log( newCode );
            offset = this.replaceCode( node, newCode );
            return length + offset;
            // console.log( node.left );
            // console.log( node.right );
        }
        return length;

        // let length = this.__proto__.BinaryExpression.call(this, node);
        
        // let binaryOperator = this.BinaryOperators[node.operator];
        // let rbinaryOperator = this.RBinaryOperators[node.operator];
        // let left = this.code.slice(node.left.start, node.left.end); 
        // let right = this.code.slice(node.right.start, node.right.end); 
        // if( binaryOperator === undefined ) { return length; }

        // console.log( node.left );
        // console.log( node.right );
        // let res, offset;
        // if( node.left.type === "Literal" && node.right.type === "Literal" ) {
        //     res = '(' + left + ' ' + node.operator + ' ' + right + ')';
        // } else if( node.left.type === "Literal") {
        //     res = right + '.' + rbinaryOperator + '(' + left + ')';
        // } else {
        //     res = left + '.' + binaryOperator + '(' + right + ')';
        // }

        // offset = this.replaceCode( node, res );
        // return length + offset;
    },

    Identifier: function( node ) {
        if( node.name === "%%" ) {
            let offset = this.replaceCode( node, this.pipeVariableName );
            return offset;
        }
        return 0;
    },
}






// acorn.Parser.prototype.parsePipeStatement = function( fooNode ) {
//     let createNewLexicalScope = !this.scopeStack.at(-1).isPipe;
//     let exitStrict = false;

//     if (createNewLexicalScope) { this.enterScope(0); this.scopeStack.at(-1).isPipe = true; }
//     else { return this.finishNode(fooNode, "ExpressionStatement"); }

//     let node = this.startNode();
//     node.body = [this.finishNode(fooNode, "ExpressionStatement")];
//     console.log( node.body );
//     console.log( node.body[0].expression.left );
//     console.log( node.body[0].expression.right );

//     while (this.type === tokTypes.pipe) {
//         this.eat(tokTypes.pipe)

//         var stmt = this.parseStatement(null);
//         node.body.push( stmt);
//     }
//     node.start = node.body[0].start;

//     if (exitStrict) { this.strict = false; }
//     if (createNewLexicalScope) { this.exitScope(); }

//     return this.finishNode(node, "PipeStatement")
// };

// function wrapper_parseExpressionStatement( wrapping ) {
//     return function (node, expr) {
//         node.expression = expr;

//         // editable
//         if(this.type === tokTypes.pipe) {
//             return this.parsePipeStatement( node );
//         }
//         return wrapping.call(this, node, expr);
//     };
// }

// function wrapper_parseExprAtom( wrapping ) {
//     return function (refDestructuringErrors, forInit) {
//         var node, canBeArrow = this.potentialArrowAt === this.start;
//         if( this.type === tokTypes.pipeResult ) {
//             var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
//             var node = this.startNode();
//             node.name = '%%';
//             this.next(false);
//             this.finishNode(node, "Identifier");

//             var id = node;
//             if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(tokTypes._function)) {
//                 this.overrideContext(types.f_expr);
//                 return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
//             }
//             if (canBeArrow && !this.canInsertSemicolon()) {
//                 if (this.eat(tokTypes.arrow))
//                 { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
//                 if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === tokTypes.name && !containsEsc &&
//                     (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
//                     id = this.parseIdent(false);
//                     if (this.canInsertSemicolon() || !this.eat(tokTypes.arrow))
//                     { this.unexpected(); }
//                     return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
//                 }
//             }
//             return id
//         }

//         return wrapping.call(this, refDestructuringErrors, forInit);
//     }
// }

// function wrapper_getTokenFromCode( wrapping ) { 
//     return function( code ) {
//         switch (code) {
//                 // editable
//             case 124: // '|'
//                 this.pos += 2;
//                 return this.finishToken(tokTypes.pipe)
//                 // editable
//             case 37: // '%%'
//                 if ( this.input.charCodeAt(this.pos + 1) === 37 ) {
//                     this.pos += 2;
//                     return this.finishToken(tokTypes.pipeResult );
//                 }
//         }
//         return wrapping.call(this, code);
//     };
// };

// acorn.Parser.prototype.parseExpressionStatement = wrapper_parseExpressionStatement(acorn.Parser.prototype.parseExpressionStatement);
// acorn.Parser.prototype.parseExprAtom = wrapper_parseExprAtom(acorn.Parser.prototype.parseExprAtom);
// acorn.Parser.prototype.getTokenFromCode = wrapper_getTokenFromCode(acorn.Parser.prototype.getTokenFromCode);






// acornWalkAST = require('acorn-walkAST');

// let UpdatePipeExpression = {
//     __proto__: acornWalkAST.UpdateNodes,
//     pipeVariableName: '__pipeOperatorVariable',

//     PipeStatement: function(node) {
//         // node.body[]
//         return this.updateNodeLocation( node, ["body"] );
//     },

//     PipeStatement: function(node) {
//         // node.body[]
//         console.log( node );
//         console.log( node.body[0] );
//         let newCode = '(function() {\nlet ' + this.pipeVariableName + ';\n' + this.code.slice(node.start, node.end);
//         let offset = this.replaceCode( node, newCode );

//         let sum = offset;
//         for(let i=0; i<node.body.length; i++) {
//             let elem = node.body[i];
//             this.updateOffset( elem, node.offset + sum );
//             newCode = this.pipeVariableName + ' = ' + this.code.slice( elem.start, elem.end ); // + ';';
//             offset = this.replaceCode( elem, newCode );
//             node.end += offset;
//             elem.start += offset;

//             sum += offset;
//             elem.offset = node.offset + sum;
//             offset = acornWalkAST.walkAST( elem, this );
//             node.end += offset;
//             sum += offset;

//             let nextElem = node.body[i+1];
//             if(nextElem != undefined) {
//                 newCode = ';'.padEnd(node.offset + sum + nextElem.start - elem.end - 1, ' ') + '\n';
//                 this.code = this.code.slice( 0, elem.end) + newCode + this.code.slice(node.offset + sum + nextElem.start);
//             } 
//         }

//         newCode = this.code.slice(node.start, node.end) + '\nreturn ' + this.pipeVariableName + ';\n})()\n';
//         sum += this.replaceCode( node, newCode );

//         return sum;
//     },

//     Identifier: function( node ) {
//         if( node.name === "%%" ) {
//             let offset = this.replaceCode( node, this.pipeVariableName );
//             return offset;
//         }
//         return 0;
//     },
// }

function compile( code, acornOptions = {ecmaVersion: 2020} ) {
    let AST = acorn.parse(code, acornOptions);
    // return AST;
    return acornWalkAST.compile( code, AST, UpdatePipeExpression );
};


module.exports = {
    // acorn: acorn,
    // walkAST: acornWalkAST,
    compile: compile,
};

