acorn = require('acorn');


tokTypes = acorn.tokTypes;
TokenType = acorn.TokenType;

tokTypes.numPostfix = new TokenType("postfix", { });


function wrapper_parseExprAtom( wrapping ) {
    return function (refDestructuringErrors, forInit) {
        var node, canBeArrow = this.potentialArrowAt === this.start;
        if( this.type === tokTypes.numPostfix ) {
            // here add code to create node from numPostfix
            var node = this.startNode();
            node.value = value;
            node.unit = this.input.slice(this.start, this.end);
            node.raw = this.input.slice(this.start, this.end);
            if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
            this.next();
            return this.finishNode(node, "Literal")

            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var node = this.startNode();
            node.name = '%%';
            this.next(false);
            this.finishNode(node, "Identifier");

            var id = node;
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(tokTypes._function)) {
                this.overrideContext(types.f_expr);
                return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
                if (this.eat(tokTypes.arrow))
                { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
                if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === tokTypes.name && !containsEsc &&
                    (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                    id = this.parseIdent(false);
                    if (this.canInsertSemicolon() || !this.eat(tokTypes.arrow))
                    { this.unexpected(); }
                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
                }
            }
            return id
        }
        return wrapping.call(this, refDestructuringErrors, forInit);
    }
}



function wrapperReadNumber( library ) {
    function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
            return null
        }

        // `BigInt(value)` throws syntax error if the string contains numeric separators.
        return BigInt(str.replace(/_/g, ""))
    }

    function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
            return parseInt(str, 8)
        }

        // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
        return parseFloat(str.replace(/_/g, ""))
    }

    return function(node, startsWithDot = false) {
        var start = this.pos;
        var end = this.pos;
        switch (this.fullCharCodeAtPos()) {
            case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
                if (!startsWithDot && this.readInt(10, undefined, true) === null) {this.raise(start, "Invalid number");}
                var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
                if (octal && this.strict) {this.raise(start, "Invalid number");}
                var next = this.input.charCodeAt(this.pos);
                if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
                    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
                    ++this.pos;
                    if (library.isIdentifierStart(this.fullCharCodeAtPos())) {this.raise(this.pos, "Identifier directly after number");}
                    return this.finishToken(types$1.num, val$1)
                }
                if (octal && /[89]/.test(this.input.slice(start, this.pos))) {octal = false;}
                if (next === 46 && !octal) { // '.'
                    ++this.pos;
                    this.readInt(10);
                    next = this.input.charCodeAt(this.pos);
                }
                if ((next === 69 || next === 101) && !octal) { // 'eE'
                    next = this.input.charCodeAt(++this.pos);
                    if (next === 43 || next === 45) {++this.pos;} // '+-'
                    if (this.readInt(10) === null) {this.raise(start, "Invalid number");}
                }

                end = this.pos;
                var val = stringToNumber(this.input.slice(start, end), octal);

                if (library.isIdentifierStart(this.fullCharCodeAtPos())) {
                    var valPostfix = this.readWord1();
                    let test = this.finishToken(library.tokTypes.num, val);
                    this.value = { numWithPostfix: true, value: val, postfix: valPostfix };
                    return;
                }

                this.finishToken(library.tokTypes.num, val);
        }
    };
};


acorn.Parser.prototype.readNumber = wrapperReadNumber( acorn );
acorn.Parser.prototype.parseExprAtom = wrapper_parseExprAtom(acorn.Parser.prototype.parseExprAtom);


acornWalkAST = require('acorn-walkAST');

let UpdateNumUnits = {
    __proto__: acornWalkAST.UpdateNodes,
    
    Literal: function( node ) {
        console.log( node );
        if( typeof node.value === 'object' ) {
            if( node.value.numWithPostfix ) {
                let newCode = 'SupportObjPostfix(' + node.value.value + ', "' + node.value.postfix + '")';
                console.log( newCode );
                let offset = this.replaceCode( node, newCode );
                return offset;
            }
        }
        return 0;
    },
}

function compile( code, acornOptions = {ecmaVersion: 2020} ) {
    let AST = acorn.parse(code, acornOptions);
    // console.log( AST.body[0].body );
    return acornWalkAST.compile( code, AST, UpdateNumUnits );
};

// acorn.compile = compile;
// module.exports = acorn;

