

let SupportBasOp = {};

SupportBasOp.toSupportBasOp = function ( value ) {
    if(typeof value === "number") {
        return new WrapperNumber( value );
    }
    return value;
};

SupportBasOp.__lt__ = function ( value ) { // <
    value = this.toSupportBasOp( value );
    return this.value < value.value;
};

SupportBasOp.__gt__ = function ( value ) { // >
    value = this.toSupportBasOp( value );
    return this.value > value.value;
},

SupportBasOp.__add__ = function ( value ) { // +
    value = this.toSupportBasOp( value );
    return this.value + value.value;
};

SupportBasOp.__radd__ = function ( value ) { // +
    value = this.toSupportBasOp( value );
    return value.value + this.value;
};

SupportBasOp.__sub__ = function ( value ) { // -
    value = this.toSupportBasOp( value );
    return this.value - value.value;
};

SupportBasOp.__rsub__ = function ( value ) { // -
    value = this.toSupportBasOp( value );
    return value.value - this.value;
};

SupportBasOp.__mul__ = function ( value ) { // *
    value = this.toSupportBasOp( value );
    return this.value * value.value;
};

SupportBasOp.__fmul__ = function ( value ) { // *
    value = this.toSupportBasOp( value );
    return value.value * this.value;
};

SupportBasOp.__div__ = function ( value ) { // /
    value = this.toSupportBasOp( value );
    return this.value / value.value;
};

SupportBasOp.__rdiv__ = function ( value ) { // /
    value = this.toSupportBasOp( value );
    return value.value / this.value;
};

SupportBasOp.__mod__ = function ( value ) { // %
    value = this.toSupportBasOp( value );
    return this.value % value.value;
};

SupportBasOp.__rmod__ = function ( value ) { // %
    value = this.toSupportBasOp( value );
    return value.value % this.value;
};

SupportBasOp.__pow__ = function ( value ) { // **
    value = this.toSupportBasOp( value );
    return this.value ** value.value;
};

SupportBasOp.__rpow__ = function ( value ) { // **
    value = this.toSupportBasOp( value );
    return value.value ** this.value;
};

SupportBasOp.__and__ = function ( value ) { // &
    value = this.toSupportBasOp( value );
    return this.value & value.value;
};

SupportBasOp.__or__ = function ( value ) { // |
    value = this.toSupportBasOp( value );
    return this.value | value.value;
};

SupportBasOp.__xor__ = function ( value ) { // ^
    value = this.toSupportBasOp( value );
    return this.value ^ value.value;
};

SupportBasOp.__not = function ( value ) { // ~
    value = this.toSupportBasOp( value );
    return ~value.value;
};

SupportBasOp.__lshift__ = function ( value ) { // << 
    value = this.toSupportBasOp( value );
    return this.value << value.value;
};

SupportBasOp.__rshift__ = function ( value ) { // >>
    value = this.toSupportBasOp( value );
    return this.value < value.value;
};

SupportBasOp.__fill_rshift__ = function ( value ) { // >>>
    value = this.toSupportBasOp( value );
    return this.value < value.value;
};

let WrapperNumber = function( number ) { 
    this.value = number;
}
WrapperNumber.prototype = SupportBasOp;

acorn = require('acorn');




acornWalkAST = require('acorn-walkAST');

let UpdateOperatorsExpression = {
    __proto__: acornWalkAST.UpdateNodes,

    BinaryOperators: {
        "<":   "__lt_",
        ">":   "__gt_",
        "+":   "__add__",
        "-":   "__sub__",
        "*":   "__mul__",
        "/":   "__div__",
        "%":   "__mod__",
        "**":  "__pow__",
        "&":   "__and__",
        "|":   "__or__",
        "^":   "__xor__",
        "<<":  "__lshift__",
        ">>":  "__rshift__",
        ">>>": "__fill_rshift__",
        "|":   "__or__",
    },
    RBinaryOperators: {
        "+":   "__radd__",
        "-":   "__rsub__",
        "*":   "__rmul__",
        "/":   "__rdiv__",
        "%":   "__rmod__",
        "**":  "__rpow__",
    },
    BinaryExpression: function (node) {
        let length = this.__proto__.BinaryExpression.call(this, node);
        
        let binaryOperator = this.BinaryOperators[node.operator];
        let rbinaryOperator = this.RBinaryOperators[node.operator];
        let left = this.code.slice(node.left.start, node.left.end); 
        let right = this.code.slice(node.right.start, node.right.end); 
        if( binaryOperator === undefined ) { return length; }

        console.log( node.left );
        console.log( node.right );
        let res, offset;
        if( node.left.type === "Literal" && node.right.type === "Literal" ) {
            res = '(' + left + ' ' + node.operator + ' ' + right + ')';
        } else if( node.left.type === "Literal") {
            res = right + '.' + rbinaryOperator + '(' + left + ')';
        } else {
            res = left + '.' + binaryOperator + '(' + right + ')';
        }

        offset = this.replaceCode( node, res );
        return length + offset;
    },

    UnaryOperators: {
        "~": "__not",
    }, 
    UnaryExpression: function (node) {
        let length = this.__proto__.UnaryExpression.call(this, node);
        
        let unaryOperator = this.UnaryOperators[node.operator];
        let argument = this.code.slice(node.argument.start, node.argument.end); 
        if( unaryOperator === undefined ) { return length; }

        let res, offset;
        if( node.argument.type === "Literal") {
            res = '(' + argument + ').' + unaryOperator + '()';
        } else {
            res = 'SupportBasOp.' + unaryOperator + '(' + argument + ')'
        }

        offset = this.replaceCode( node, res );
        return length + offset;
    },
};

function compile( code, acornOptions = {ecmaVersion: 2020} ) {
    let AST = acorn.parse(code, acornOptions);
    // console.log( AST.body[0].body );
    return acornWalkAST.compile( code, AST, UpdateOperatorsExpression );
};

module.exports = {
    acorn: acorn,
    walkAST: acornWalkAST,
    compile: compile,
};

